# Spring boot核心作用

1. 起步依赖

`spring-boot-starter-xxx`会聚合很多的依赖包，包括内嵌tomcat服务器等，这样我们在引入依赖时只需要添加起步依赖即可。很方便

2. 自动配置，不需要自己编写配置文件
3. 端点监控



# 记录

1. 我们从Dao层开始开发，且一个数据表对应一个mapper，mapper和对应的配置文件写完就进行测试，这是因为xml文件不会报错，排错比较麻烦，所以先进行小的单元测试，测试没问题再进行下一步的开发。

2. 响应状态码：

   >302:重定向。使用低耦合的方式进行一个功能的跳转（例如注册完账号后跳到登录服务。）
   >
   >比如客户端调用服务器的删除帖子的请求，但是返回数据时需要用到查询的服务，这事并不是在服务器内部中使用删除的服务区调用查询的服务，而是客户端返回一个302响应状态码，并附上一个查询服务的访问地址，其建议客户端去访问这个地址。
   >
   >302+location
   >
   >4xx：客户端问题
   >
   >5xx: 服务端问题



# 开发注册功能

把整个功能的开发过程拆解为三步：

## 1.访问注册页面

- 点击顶部区域内的连接，打开注册页面

## 2.提交注册数据

- 通过register页面表单提交数据
- 服务端验证账号是否存在，邮箱是否已注册
- 服务端发送激活邮件

## 3.激活注册账号

- 点击邮件中的链接，访问服务端的激活服务。跳转到operate-result页面，并自动跳转到相应的页面

# 

# 会话管理

- Http有哪些基本的性质
  - HTTP是简单，可扩展的
  - 无状态，有会话。（可以通过cookie解决无状态的问题。）
- cookie
  - 是服务器发送给浏览器（在响应头中），并保存在浏览器端的一块数据。
  - 浏览器下次访问该服务时，会自动携带该数据（在请求头中），将其发送给服务器
  - cookie的缺点是不安全，所以不要将重要信息存在cookie中。。可以存在redis数据库中
- Session
  - 是JavaEE的标准，用于在服务端记录客户端信息。
  - 数据存放在服务端更加安全，但是也会增加服务端的内存压力，在分布式部署中，session同步也是一个麻烦事。





# 开发登录功能

- 访问登录页面
  - 点击顶部区域内的链接，打开登录页面
- 登录
  - 验证账号，密码，验证码
  - 成功时，生成登录凭证，发送给客户端
  - 失败时，跳转回登录页面
- 退出
  - 将登录凭证修改为失效状态
  - 跳转至登录页面。



# 页面头部显示登录信息

- 拦截器示例

  - 定义拦截器，实现HandlerInterceptor
  - 配置拦截器，为其指定拦截，排除的路径

- 拦截器应用

  - 在controller请求开始时查询登录用户的信息
  - 在本次controller请求中持有用户数据
  - 在模板视图上显示用户数据
  - 在请求结束时清理用户数据

  ![显示登录信息的流程图.png](https://github.com/ZEQINLIN-666/MyCommunity/blob/master/image/%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true)

# 账号设置，可以上传头像

- 上传文件
  - 请求必须是POST请求
  - 在html文件的表单标签中，需是`enctype = "multipart/form-data"`
  - Spring MVC:通过MultipartFile处理上传文件
- 开发步骤
  - 访问账号设置的页面
  - 上传头像
  - 页面获取头像



# 检查登录状态（防止安全漏洞）

某些页面只有登录后才能访问得到

我们通过注解和拦截器的方式来对登录状态进行检测

- 使用拦截器

  - 在方法当前标注自定义注解@LoginRequired
  - 拦截所有请求，只处理带有该注解的方法

- 自定义注解

  - 常用的元注解

    - @Target、@Retention、@Document、@Inherited

  - 如何读取注解

    Method.getDeclaredAnnotations()

    Method.getAnnotation(Class<T> annotiationClass)

    ```java
    if (handler instanceof HandlerMethod) {
                HandlerMethod handlerMethod = (HandlerMethod) handler;
                Method method = handlerMethod.getMethod();
                //当方法上有LoginRequired注解就执行操作
                LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
                if (loginRequired != null && hostHolder.getUser() == null) {
                    response.sendRedirect(request.getContextPath() + "/login");
                    return false;
                }
            }
    ```

    

# 过滤敏感词

## 实现

利用前缀树这种数据结构来实现

![前缀树.PNG](https://github.com/ZEQINLIN-666/MyCommunity/blob/master/image/%E5%89%8D%E7%BC%80%E6%A0%91.PNG?raw=true)

- 特点

  查找效率高，消耗内存大

- 应用：

  字符串检索，词频统计，字符串排序

## 敏感词过滤代码实现

- 定义前缀树

  ```java
  private class TrieNode {
  
          // 关键词结束标识
          private boolean isKeywordEnd = false;
  
          // 子节点(key是下级字符,value是下级节点)
          private Map<Character, TrieNode> subNodes = new HashMap<>();
  
          public boolean isKeywordEnd() {
              return isKeywordEnd;
          }
  
          public void setKeywordEnd(boolean keywordEnd) {
              isKeywordEnd = keywordEnd;
          }
  
          // 添加子节点
          public void addSubNode(Character c, TrieNode node) {
              subNodes.put(c, node);
          }
  
          // 获取子节点
          public TrieNode getSubNode(Character c) {
              return subNodes.get(c);
          }
  
      }
  ```

  

- 根据敏感词，初始化前缀树

  ```java
  @PostConstruct
      public void init() {
          try (
                  InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                  BufferedReader reader = new BufferedReader(new InputStreamReader(is));
          ) {
              String keyword;
              while ((keyword = reader.readLine()) != null) {
                  // 添加到前缀树
                  this.addKeyword(keyword);
              }
          } catch (IOException e) {
              logger.error("加载敏感词文件失败: " + e.getMessage());
          }
      }
  ```

  

- 编写过滤敏感词的方法

```java
/**
     * 过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1
        TrieNode tempNode = rootNode;
        // 指针2
        int begin = 0;
        // 指针3
        int position = 0;
        // 结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()) {
            char c = text.charAt(position);

            // 跳过符号
            if (isSymbol(c)) {
                // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间,指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现敏感词,将begin~position字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }
// 将一个敏感词添加到前缀树中
    private void addKeyword(String keyword) {
        TrieNode tempNode = rootNode;
        for (int i = 0; i < keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);

            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 指向子节点,进入下一轮循环
            tempNode = subNode;

            // 设置结束标识
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }
```

# 发布帖子（AJAX）

使用ajax，网页能够将增量更新呈现在页面上，不需要刷新整个页面。（异步方式）



## 实现发布帖子

首先编写一个转json的静态通用方法（fast-json）

```java
public static String getJSONString(int code, String msg, Map<String,Object> map){
        JSONObject json = new JSONObject();
        json.put("code",code);
        json.put("msg",msg);
        if(map != null){
            for(String key:map.keySet()){
                json.put("key",map.get(key));
            }
        }
        return json.toJSONString();
    }
```



- 在DiscussPostMapper中新增插入帖子的方法

- 在Service层实现调用mapper，添加帖子

  - 这里需要对输入的标题和正文进行HTML标签的转义并过滤敏感词

    ```java
     //转义HTML标签
            post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));
            post.setContent(HtmlUtils.htmlEscape(post.getContent()));
    
            //过滤敏感词
            post.setTitle(sensitiveFilter.filter(post.getTitle()));
            post.setContent(sensitiveFilter.filter(post.getContent()));
    
    ```

    

- controller层通过传入title和content数据，利用ajax在浏览器和服务器之间进行交互

  - 异步交互，需要编写js方法

    ```javascript
    function publish() {
        //点击发布后，输入框自动消失
    	$("#publishModal").modal("hide");
    
    	//获取标题和内容
    	var title = $("#recipient-name").val();
    	var content = $("#message-text").val();
    
    	//发送异步请求(POST)
    	$.post(
    		CONTEXT_PATH + "/discuss/add",
    		{"title":title,"content":content},
    		function(data){
    			data = $.parseJSON(data);
    			//在提示框中显示返回消息
    			 $("#hintBody").text(data.msg);
    			 //显示提示框
    			 $("#hintModal").modal("show");
    			 //2秒后自动隐藏提示框
    			 setTimeout(function(){
    				 $("#hintModal").modal("hide");
    				 //如果帖子发布成功，刷新页面
    				 if(data.code == 0){
    				 	window.location.reload();
    				 }
    			 }, 2000);
    		 }
    	);
    }
    ```

    

    

## 小问题

首页在未登录的时候，有“我要发布”按钮，需要解决。

解决方式：

```html
<button type="button" class="btn btn-primary btn-sm position-absolute rt-0" data-toggle="modal" data-target="#publishModal" th:if="${loginUser!=null}">我要发布</button>
```

添加`th:if="${loginUser!=null}"`



# 显示帖子详情

1. DiscussPostMapper,添加查询方法，编写select 语句
2. DiscussPostService 添加查询方法
3. DiscussPostController编写视图层，将用户信息和帖子信息传入
4. index.html,在帖子标题上添加访问详情页面的连接
5. discuss-detail.html
   - 处理静态资源的访问路径
   - 复用indexhtml的header区域
   - 显示标题，作者，发布时间，帖子正文等。

